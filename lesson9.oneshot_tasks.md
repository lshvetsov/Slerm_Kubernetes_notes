Однократные, разовые задачи - миграции, бэкап, подготовка окружения и т.д.

# Job

Под капотом запускается под, которые выполняет задачу и переходит в статус Completed. Внутри - какой-то скрипт. 
Если возникает проблема - перезапусает под до успешного выполнения (backoffLimit) или достижения timeout (activeDeadLineSecond).

* Джоба удаляется только в случае настройки специфичной настройки ttl_controller. 
* Порядок запуска джобов можно определить сторонними инструментми (helm)
* По дефолту - TMZ ControllerManager (нужно правильно настроить время на хостах), параметр CronTZ

## Спецификация
* kind - Job 
* backoffLimit - количество повторов создания **пода** (при ошибках - определяется по кодам выхода)
* activeDeadlineSeconds - ограничение по времени (после - убивает под) 
* template - описание пода (image, args)
	** `restartPolicy` - политика перезапуска **контейнеров** (Never - контейнер не перезапусается, запусается новый под; Always - рестарт контенера, не пода; OnFavour)
	** `ttlSecondsAfterFinished` - время (секунды), которое сохраняется джоба после ее выполнения
	** `completions` - желаемое количество успешно выполненных сценариев (по сути подов) в рамках джоба (default = 1)
	** `parallelism` - запуск нескольких подов (с одной задачей) в рамках джобы (default = 1)

## Запуск	
``` bash
kubectl create -f job.yml
kubectl get job   # посмотреть джобы (можно так же запросить под)
kubectl logs <pod_name>    # посмотреть логи
```

## Диагностика
```bash
kubectl describe job <job_name> # залесть и посмотреть события 
```

## Best practices
* backoffLimit + activeDeadlineSeconds - чтобы не выстелить себе в ногу (условия автозавершения)
* restartPolicy - задать политику перезапуска
* Если нужно запустить что-то на всех нодах - использовать сущность deamonSet

# Cronjob

Запуск задач (джобов) по расписанию: cronjob создает job, которые создают pod для выполнения задачи

apiVersion: batch/v1beta1 c 20 или 21 версии -> apiVersion: batch/v1

**Важные параметры:**
* `spec.shedule` - расписание выполнения задания (cron)
* `spec.concurrentPolicy` - что делать, если к моменту запуск джобы предыдущая незавершена: 
	** allow - несколько допустимо, 
	** forbid - запрещено, только после достижения job  статус completed (_best practice_), 
	** replace - заменить (запустить новый вместо)
* `Successful Job History Limit` - количество сохраненных джобов (успешных), более старые удаляются (default = 3) - (_best practice_)
* `Failed Job History Limit` - количество сохраненных джобов (ошибка), более старые удаляются (default = 1) - (_best practice_)
* `spec.startingDeadlineSeconds` - запас времени для запуска cj: например, если произошла небольшая задержка, несколько секунд, при запуске (запустили не 0:00, а в 0:01) из-за лага в обработке команды в kubernetes (например). 
	** если stardtingDeadlineSeconds не задано + количество пропущенных запусков больше 100, то cj считается "сломанным" (больше не создает джобы) -> нужно пересоздавать. Такое может быть в случае недостпности компонентов kubernetes. Пример - запуск 1 мин, не запускали 3 часа (180 мин), количество проущенных запусков = 180/1 = 180
	** если stardtingDeadlineSeconds задано, то количество пропущенных запусков считается от него. Пример - запуск 1 мин, не запускали 3 часа (180 мин), stardtingDeadlineSeconds = 20, количество проущенных запусков = 20/1 = 20 (cj не сломана) 

## Запуск
``` bash
kubectl create -f cronjob.yml
kubectl get cj   # посмотреть джобы по расписанию (можно так же запросить под)
kubectl logs <pod_name>    # посмотреть логи
```

Приостановить выполнение - вручную поменять в спецификации cronjob suspend:false -> true. 

## Best practices

* `spec.concurrentPolicy` = Forbid (избежать параллельного запуска и конкуренции)
* установить `Successful Job History Limit` / `Failed Job History Limit`, если не подходит дефолтные
* `spec.stardtingDeadlineSeconds` = от 10 секунд до промежутка запуска
* **Важно**: джобы для cron должны быть идемпотенты, тк может быть запущен не один job (иногда 0, иногда 2)

# QA

1. На что может повлиять большое количество подов в статусе completed?
	* может тормозить докер: completed pod - контенер в статусе pause, если их больше сотни, могут быть "тормоза"
	* продуктивность кластера: каждый объект - запись в БД etcd, чем их больше, тем медленнее будет работать кластер.

2. Логирование - демон fluentbeat, собирающий логи
 



