**Date** 11.11.2021

Frontend - скомпилировали статику и положили на nginx.

# Best Practices в docker

1. Multistage-сборки
В рамках одного докер файла сначала собираем нужный бинарник (в неком базовом образе) -> потом запускаем новый числый базовый образ, где этот бинарник запускаем. 
```bash
# syntax=docker/dockerfile:1
FROM golang:1.16 AS builder
WORKDIR
Learn more about the "WORKDIR" Dockerfile command.
 /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go    ./
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /go/src/github.com/alexellis/href-counter/app ./
CMD ["./app"]  
```
2. Контейнеры запускаются не от root 
Директива `USER`. root имеет слишком много прав + уязвимости внутри контейнера (выйти на host, тоже в root). 

3. Один процесс = один контейрер. 
Если рассмотреть kubernetes как кластерную операционную системы - то контейнер = процесс. 

4. Не использовать версию latest или неявные версии образов. 
На в репозитрии в конвейере сборки могут быть другие версии, что приведет к проблемам в продуктиве, не эмилируемых локально.  

5. Не обновлять систему в контейнере (apt-get update).
Каждый раз можем получить разный набор пакетов. 

6. Минимизация всего в контейнере. 
Не использовать большие ОС как базовые образы - ubuntu, centrOS. \
Зачем минимализируем образы: 
- снижаем риски атак,
- медленнее поднимаются при перезапуске,
- много места для хранения.
Количество слоев не имеет значения (предрассудок пошел от старой файловой системы overlayfs1, где поддерживались 20 слоев).

7. Если необходимо что-то использовать и удалить - писать в рамках одной инструкции `RUN`.
Если писать в рамках нескольких, то каждая из них - это слой, поэтому размер образа не уменьшается при удалении + можно провалиться на нижлежащие слои и получить какую-то информацию. 
``` bash
# no
RUN 1
RUN 2
RUN 3
# yes 
RUN 1 && 2 && 3
```
8. Использовать внутреннее кэширование docker. 
```bash
COPY requirements.txt
RUN pip install -r requirements.txt  # download requirements
COPY . .  # copy all code
```
В этом примере зависимости (requirements) меняются редко, поэтому слои 1 и 2 будут просто пропускаться, а код часто - поэтому этот слой последний: изменение кода не приведет к пересборке всего проекта (скачиваю всех зависимостей)

# Java/C#


# Интерпретируемые языки (python, ruby, php)


# GoLang