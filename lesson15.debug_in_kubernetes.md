# Дебаг приложений в кластере kubernetes

*Проблемы*:
- отсутствие лишних утилит в контейнере (best practices работы с контейнером)
- запрос exec на проде (вход в контейнер)
- readonly файловая система в контейнере

## Встроенный возможности kubenetes

1. `kubectl describe ...` - описание объекта kubernetes (описание состояния, переменные, статус, порты, и т.д.)
Наример, смотреть termination reason: OM killed - не хватило RAM, error - какая-то ошибка в приложении, нужно смотреть логи. Решает порядка 70% случаев. \
_Best practice_. Можно добавить параметр deployment (спецификация pod) terminationMessagePolicy: FallbackToLogOnError, чтобы выводить в describe последние 80 строк лога или 2Ki. 
2. `kubectl get events` - посмотреть события kubernrtes при запуске приложения (1 час по default)
3. `kubectl logs <pod_name> (--previous)` - посмотреть логи (previous - предыдущего пода, если перезапущен самим kubernetes)

Важно - ответственно относится к логированию ВНУТРИ приложения. 

## Профилировщики

Программа, подключающаяся по сети (отдельный порт, подключение через ingress), и отслеживает состояние программы. \
- Java: Actuator, JProfiler, Prometheus
- Python/PHP/Ruby: Prometheus, Rookout
- Go: Pprof

`Не использовать на ПРОД!` Профилировщик останавлиает процесс, поэтому есть риск заDDOSить приложение. 

## Дебаг из контейнера

Проблема с exec - не хватит ресурсов, на контейнер выделяется мало -> *Best Practice*: еще один контейнер, копия основного, но для дебага (другие лейблы). 

## Best practices по работе с контенерами в проде

1. Логи приложения должны быть информативны.
2. Метрики должны быть информативны
3. Application console можно реализовать через технические API.

# QA

1. В связи с переходом на runtime среду исполнения CRIO стоит ли забыть про докер?
Нет, это более широкий набор инструментов: Dockerfile, docker-compose, репозитории. Конкретно kubernetes - просто изменяет инструмент для production, более легковестный. Docker - это в будущем скорее инструмент разработки. 

2. Как кастомизировать вывод информации kubectl?
Ключ -o для выбора формата вида (json, yml). Можно добавить плагины через krew. Можно использовать библиотеки взаимодействия с API kubernetes. 

3. Как централизовано собирать логи в kubernetes?
Elastic search(хранение) + Kibana(визуализация) + Fluentbeat(сборщики логов, доп контейнер или deamonset на ноде, читает файлы логов контейнеров и отправляет их в хранилище) \ 
ELK -> EFK (logstash -> fluentbeat)

4. Как использовать метрику использования CPU?
Классическая метрика железных сервров и виртальных машин, в случае контенеров лучше смотреть на trottling. 