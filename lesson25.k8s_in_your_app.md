# Возможности k8s

## Используем Kube-API руками

*Service account* - токен доступа в Kube-API (по сути УЗ запись приложения). \ 
Обратиться к Kube-API: https:\\kubernetes.default

В каждом namespace есть sa default, который принимает поды без указания sa. \
Если войти в такой под, то внутри можно найти файлы в диретории var/run/secrets/kubernetes.io/serviceaccount/:
- ca.crt - ключ от кластера
- namespace - указание в каком namespace запущен под
- token - токен от sa.

Если нужно обратиться к Kube-API из пода(приложения), то можно сдалеть запрос:
```
curl https:\\kubernetes.default --cacert <path to ca.crt> -H "Authorization: Bearer <token>"
```

## Примеры использования в приложениях

- автоматическое создание подов для задач (выполнение задач от пользователя: вместо создания worker, создаем под с Job в k8s)
- получить ip всех подов в сервисе (кластеризация rabbitMQ),
- распределенный lock
Проблема - есть приложение, которое должно работать в каждый момент времени в одном экземпляре, но в случае проблем с подов не должно быть downtime. Решение - абстракция *lease*: `indentity` - ссылка на основной объект + период обновления + дата последнего обновления; не обновился - не доступен, значит другой экземпляр должен попробовать перехватить *lease*. 
- передача информации через ConfigMap: одно приложение меняет configMap, изменения -> приезжают во все поды, где используется этот configMap. 
- создание собственных операторов

## Подключение взаимодействия с Kube-API в приложение

Чтобы подключить в приложение - использовать [клиентские библиотеки](https://kubernetes.io/docs/reference/using-api/client-libraries/) (официальные или comunity). \

## Собственные операторы

Можно описать свою абстракцию (Custom resource definition, yaml) и контроллеры, которые будут с ней работать (Custom operators). 

Смотреть KubernetesOperatorHub - все уже создано. 

Чтобы написать свой оператор - [OperatorSDK](https://sdk.operatorframework.io/), останется только описать конкретную работу: какие объекты получить из кластера, как обработать, что вернуть/сделать. \
Способы написание операторов: 
- код на go,
- создаение чего-то на основе helm-chart (пример пользовать задает параметры БД, которые соответствуют values.yml чарта)
- ansible (написание тасков)

# Trottling

_Лимит на память_ - при превышении, приходить OM killer и убивает приложение.
_Лимит на CPU_ - выделяется точное процессорное время в рамках processor period (100 mCPU = 10% от CPU, если период установлен 100 мс, то это 10 мс на приложение).

Trottling - это ситуация, когда работа приложения замедляется в разы: операция требует 50 мс, процессорный период 100 мс, выделяется по лимиту 10%, 10 мс. Соответственно задача будет занимать на 50 мс, а в разы больше, потому, что процессор отнимается у приложения. \
Может отслеживаться метрикой мониторинга (Prometheus).   

# Links:
1. CNCF Landscape (https://landscape.cncf.io/) 